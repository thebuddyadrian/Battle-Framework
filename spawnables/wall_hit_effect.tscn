[gd_scene load_steps=18 format=3 uid="uid://cvj3krmatl3ij"]

[ext_resource type="Resource" uid="uid://bv2edat0khvum" path="res://spawnables/ShotData/DashEffect.tres" id="2_5nrjf"]
[ext_resource type="Script" uid="uid://csae2nyvo6aiw" path="res://components/hitbox/hit_data.gd" id="4_m3ivo"]
[ext_resource type="Texture2D" uid="uid://dbk1gpee8yf45" path="res://assets/Misc Effects/Sonic battle misc effects indv Spritesheet.png" id="6_bycy1"]

[sub_resource type="GDScript" id="GDScript_1gnx5"]
script/source = "extends BaseSpawnable
var animation_ended: bool
func _on_spawn(data: = {}):
	var dir = Input.get_axis(\"right1\", \"left1\")
	$Sprite.play(\"Anim\")
	print(dir)
	if dir <= 0:
		$Sprite.flip_h = false
	else:
		$Sprite.flip_h = true


func _on_sprite_animation_finished() -> void:
	queue_free()"

[sub_resource type="GDScript" id="GDScript_7meyc"]
script/source = "@tool
class_name Hitbox
extends Area3D

const REBOUND_THRESHOLD: int = 20
# const HIT_SPARK_PATH = \"res://Effects/HitSparkEffect/HitSparkEffect.tscn\"
# const CLASH_EFFECT_PATH = \"res://Effects/ClashEffect/ClashEffect.tscn\"

@export var hit_data: HitData = HitData.new()
@export var active := false : set = set_active
@export var root_node_path: NodePath
#Z@export var hit_spark_pos_node_path: NodePath
@export var is_static: bool = false # For Projectiles with hitboxes that never change
@export var total_area: float = 0

var nodes_already_hit = []
var character_last_hit := \"\" # Node name of character last hit
var character_grabbed := \"\" # Node name of character currently grabbed
var initial_hit_data: Resource
var initial_rects = []
var player_id: int = 0

@onready var root = get_node(root_node_path)
# @onready var hit_spark_pos_node: SGFixedNode2D = get_node_or_null(hit_spark_pos_node_path)
# @onready var stage = CurrentMatch.root

signal hit(hit_data: HitData, hurtbox: Hurtbox)
signal clash
signal grab
signal blocked


func _ready():
	assert(root_node_path, \"Must set a root node for %s!\" % name)
	#Make sure hit info isn't shared between multiple hitbox groups
	hit_data = hit_data.duplicate(true)
	# Used to reset the Hitbox to it's initial state
	initial_hit_data = hit_data
	#initial_rects = rects.duplicate(true)
	add_to_group(\"network_sync\")
	add_to_group(\"hitbox_group\")

	if root is BattleCharacter:
		player_id = root.player_id
	if root is BaseSpawnable:
		if root.summoner is BattleCharacter:
			player_id = root.summoner.player_id
	


func reset():
	nodes_already_hit.clear()
	active = false
	hit_data = initial_hit_data
	hit_data.root_name = \"\"
	hit_data.direction = 1
	character_last_hit = \"\"
	character_grabbed = \"\"
	#rects = initial_rects.duplicate(true)
	# fixed_position = SGFixed.vector2(0,0)
	# fixed_rotation = 0


# func _process(delta):
# 	if Engine.is_editor_hint():
# 		total_area = 0
# 		for rect in rects:
# 			total_area += rect.get_area()
# 	else:
# 		if Global.visible_hitboxes:
# 			visible = active
# 		else:
# 			visible = false


func check_if_hit(hurtbox) -> bool:
	if !active: 
		return false
	if hurtbox.is_in_group(\"hurtbox_group\"):
		if hurtbox.active:
			if hurtbox.root is BattleCharacter:
				if hurtbox.root.invincibility_frames > 0:
					return false
			if (hurtbox.can_be_hit and hurtbox.mode == Hurtbox.MODE.NORMAL):# or (hit_data.type == HitData.MOVE_TYPES.GRAB and hurtbox.can_be_grabbed):
				if !(get_path_to(hurtbox.root) in nodes_already_hit):
					if hurtbox.root != root and hurtbox.player_id != player_id:
						return true
	return false


func check_if_clash(hitbox) -> bool:
	if !active:
		return false
	if hitbox.is_in_group(\"hitbox_group\"):
		if hitbox.active:
			if !(hitbox.root.is_in_group(\"characters\")): return true
			if !(get_path_to(hitbox.root) in nodes_already_hit):
				return true
	return false
		

func check_if_blocked(hurtbox) -> bool:
	if !active: return false
	if hit_data.unblockable: return false
	if hurtbox.is_in_group(\"hurtbox_group\"):
		if hurtbox.active and hurtbox.can_be_hit and hurtbox.mode == Hurtbox.MODE.SHIELD:
			#if hurtbox.root.team_id != root.team_id and !(get_path_to(hurtbox.root) in nodes_already_hit):
				#return true
			if !(get_path_to(hurtbox.root) in nodes_already_hit):
				return true
	return false


func is_hitting_wall() -> bool:
	if !active: return false
	for body in get_overlapping_bodies():
		if body.is_in_group(\"platform\"):
			return true
	return false

# Tell the hurtbox they were hit
func do_hit(hurtbox):
	nodes_already_hit.append(get_path_to(hurtbox.root))
	
	var processed_hit_data: HitData = hit_data.duplicate(true)
	if root.has_method(\"_hit_data_preprocess\"):
		root._hit_data_preprocess(processed_hit_data)
		
	# if processed_hit_data.type == HitData.MOVE_TYPES.GRAB:
	# 	if !character_grabbed and hurtbox.root.is_in_group(\"character\"):
	# 		hurtbox.get_grabbed(processed_hit_data.duplicate(), self)
			
	# 		if !hurtbox.is_connected(\"escaped_grab\", self, \"opponent_escaped_grab\"):
	# 			hurtbox.connect(\"escaped_grab\", self, \"opponent_escaped_grab\")
	# 		#emit_signal(\"grab\", processed_hit_data, hurtbox)
	# 		if root.has_method(\"_hitbox_grab\"):
	# 			root._hitbox_grab(processed_hit_data, hurtbox)
	# 		character_last_hit = hurtbox.root.name
	# 		character_grabbed = hurtbox.root.name
	# 	return
		
	character_last_hit = hurtbox.root.name
	print(\"Hitbox.gd: %s\" % processed_hit_data.knockback_direction)
	emit_signal(\"hit\", processed_hit_data, hurtbox)
	hurtbox.get_hit(processed_hit_data.duplicate(true), self)
#	spawn_hit_spark_effect(hurtbox.get_global_fixed_position().x)


# func clash(hitbox):
# 	var self_priority: int = hit_data.damage if hit_data.priority_override < 0 else hit_data.priority_override
# 	var other_priority: int = hitbox.hit_data.damage if hitbox.hit_data.priority_override < 0 else hitbox.hit_data.priority_override
# 	var rebound: bool = self_priority <= other_priority + REBOUND_THRESHOLD
# 	if rebound:
# 		nodes_already_hit.append(get_path_to(hitbox.root))
# 	#emit_signal(\"clash\", hit_data, hitbox)
# 	if root.has_method(\"_hitbox_clash\"):
# 		root._hitbox_clash(hit_data, hitbox, rebound)
# 	spawn_clash_effect(hitbox)


# func get_hit_fx_position() -> SGFixedVector2:
# 	if hit_spark_pos_node:
# 		return hit_spark_pos_node.get_global_fixed_position()
# 	return SGFixed.vector2(hit_data.fx_position_x, hit_data.fx_position_y).add(get_global_fixed_position())


# func spawn_hit_spark_effect(pos_x: int = get_hit_fx_position().x, pos_y: int = get_hit_fx_position().y):
# 	var data = {
# 		fixed_position_x = pos_x,
# 		fixed_position_y = pos_y,
# 		color = hit_data.fx_color_hex,
# 	}
# 	SyncManager.spawn(\"HitSparkEffect\", stage, load(HIT_SPARK_PATH), data.duplicate(true))


# func spawn_clash_effect(area_clashed: SGContactBoxGroup):
# 	var my_pos = SGFixed.vector2(get_global_fixed_position().x, get_hit_fx_position().y)
# 	var other_pos = SGFixed.vector2(area_clashed.root.get_global_fixed_position().x, area_clashed.get_hit_fx_position().y)
# 	var midpoint = my_pos.add(other_pos).div(2*65536)
	
# 	var data: Dictionary = {
# 		fixed_position_x = midpoint.x,
# 		fixed_position_y = midpoint.y,
# 	}
	
# 	SyncManager.spawn(\"ClashEffect\", stage, load(CLASH_EFFECT_PATH), data.duplicate(true))


func confirm_blocked(hurtbox):
	nodes_already_hit.append(get_path_to(hurtbox.root))
	hurtbox.get_hit(hit_data.duplicate(true), self)
	character_last_hit = hurtbox.root.name
	emit_signal(\"blocked\", hit_data, hurtbox)
	#spawn_hit_spark_effect(hurtbox.get_global_fixed_position().x)


# func release_grabbed_opponent():
# 	if !character_grabbed: return
# 	var character_node = CurrentMatch.get_character(character_grabbed)
# 	if character_node.is_in_group(\"character\"): character_node.hurtbox.released_from_grab(self)
# 	character_grabbed = \"\"


func opponent_escaped_grab():
	character_grabbed = \"\"


func set_active(_active: bool):
	active = _active
	if active:
		nodes_already_hit.clear()


func _save_state() -> Dictionary:
	var state = {
		#rects = rects.duplicate(true),
		active = active,
		nodes_already_hit = nodes_already_hit.duplicate(true),
		# fixed_position_x = fixed_position.x,
		# fixed_position_y = fixed_position.y,
		# fixed_rotation = fixed_rotation,
		character_last_hit = character_last_hit,
		character_grabbed = character_grabbed,
	}
	if !is_static:
		state[\"hit_data\"] = hit_data.get_as_dict()
	else:
		state[\"hit_data_direction\"] = hit_data.direction
	return state


func _load_state(_state: Dictionary):
	active = _state[\"active\"]
	# rects = _state[\"rects\"].duplicate(true)
	# nodes_already_hit = _state[\"nodes_already_hit\"].duplicate(true)
	# fixed_position.x = _state[\"fixed_position_x\"]
	# fixed_position.y = _state[\"fixed_position_y\"]
	# fixed_rotation = _state[\"fixed_rotation\"]
	# if _state.has(\"hit_data\"):
	# 	hit_data = Functions.hit_data_from_dict(_state[\"hit_data\"].duplicate(true))
	if _state.has(\"hit_data_direction\"):
		hit_data.direction = _state[\"hit_data_direction\"]
	character_grabbed = _state[\"character_grabbed\"]
	character_last_hit = _state[\"character_last_hit\"]
	# update_contact_boxes()
	# sync_to_physics_engine()
"

[sub_resource type="Resource" id="Resource_fuwwp"]
script = ExtResource("4_m3ivo")
damage = 10.0
knockback_direction = Vector2(0, 0)
knockback_power = 13.0
knockback_angle = 45.0
knockback_type = 4
unblockable = false
hit_freeze = 5
hit_stun = 30

[sub_resource type="SphereShape3D" id="SphereShape3D_fc865"]
radius = 0.51228

[sub_resource type="GDScript" id="GDScript_v1h67"]
script/source = "@tool
class_name Hurtbox
extends Area3D

enum MODE {NORMAL, SHIELD}

var grabbed_by = \"\"
var initial_rects = []
var initial_is_reflector: bool
var player_id: int = 0 # Hitboxes cannot hit hurtboxes with the same player_no

signal hurt(hit_data: HitData, hitbox: Hitbox)
signal grabbed
signal escaped_grab
signal released_from_grab
signal thrown

@export var mode: MODE = MODE.NORMAL
@export var active = false
@export var can_be_grabbed = true
@export var can_be_hit = true
@export var root_node_path: NodePath
@export var hit_pause_override := -1
@export var is_reflector = false



@onready var root = get_node(root_node_path)

func _ready():
	assert(root_node_path, \"Must set a root node!\")
	add_to_group(\"network_sync\")
	add_to_group(\"hurtbox_group\")
	# initial_rects = rects.duplicate(true)
	initial_is_reflector = is_reflector

	if root is BattleCharacter:
		player_id = root.player_id
	if root is BaseSpawnable:
		if root.summoner is BattleCharacter:
			player_id = root.summoner.player_id
	

func _network_process(_input):
	pass # Hitboxes and Hurtboxes are processed inside BaseStage.gd


# func _process(delta):
# 	if !Engine.is_editor_hint():
# 		visible = Global.visible_hurtboxes


func reset():
	active = false
	# rects = initial_rects.duplicate(true)
	# fixed_position = SGFixed.vector2(0,0)
	# fixed_rotation = 0
	mode = MODE.NORMAL
	grabbed_by = \"\"
	can_be_grabbed = true
	can_be_hit = true
	hit_pause_override = -1
	is_reflector = initial_is_reflector


func get_hit(hit_data, area_hurt_by: Hitbox):
	if root is BattleCharacter:
		if root.invincibility_frames > 0:
			return
	if active and can_be_hit: 
		if mode == MODE.NORMAL:
			emit_signal(\"hurt\", hit_data.duplicate(true), area_hurt_by)
		elif mode == MODE.SHIELD:
			emit_signal(\"blocked\", hit_data.duplicate(true), area_hurt_by)


func get_grabbed(hit_data, area_grabbed_by: Hitbox):
	if !active: return
	if !can_be_grabbed: return
	grabbed_by = area_grabbed_by.root.name
	#emit_signal(\"grabbed\", hit_data.duplicate(true), area_grabbed_by)
	if root.has_method(\"_hurtbox_grabbed\"):
		root._hurtbox_grabbed(hit_data.duplicate(true), area_grabbed_by)


func get_released_from_grab(area_released_from: Hitbox):
	if !grabbed_by: return
	grabbed_by = \"\"
	emit_signal(\"released_from_grab\", area_released_from)


func get_thrown(area_thrown_by: Hitbox):
	if !grabbed_by: return
	grabbed_by = \"\"
	#emit_signal(\"thrown\", area_thrown_by)
	if root.has_method(\"_hurtbox_thrown\"):
		root._hurtbox_thrown(area_thrown_by)


func escape_from_grab():
	if !grabbed_by: return
	grabbed_by = \"\"
	#emit_signal(\"escaped_grab\")
	if root.has_method(\"_hurtbox_escaped_grab\"):
		root._hurtbox_escaped_grab()


func _save_state() -> Dictionary:
	return {
		#rects = rects.duplicate(true),
		active = active,
		mode = mode,
		grabbed_by = grabbed_by,
		can_be_grabbed = can_be_grabbed,
		can_be_hit = can_be_hit,
		hit_pause_override = hit_pause_override,
		is_reflector = is_reflector,
	}


func _load_state(_state: Dictionary):
	#rects = _state[\"rects\"].duplicate(true)
	active = _state[\"active\"]
	mode = _state[\"mode\"]
	grabbed_by = _state[\"grabbed_by\"]
	can_be_grabbed = _state[\"can_be_grabbed\"]
	can_be_hit = _state[\"can_be_hit\"]
	hit_pause_override = _state[\"hit_pause_override\"]
	is_reflector = _state[\"is_reflector\"]
	# update_contact_boxes()
	# sync_to_physics_engine()
"

[sub_resource type="SphereShape3D" id="SphereShape3D_kpalt"]
radius = 0.254871

[sub_resource type="BoxShape3D" id="BoxShape3D_voyo2"]
size = Vector3(0.70697, 1, 0.717041)

[sub_resource type="AtlasTexture" id="AtlasTexture_xw5af"]
atlas = ExtResource("6_bycy1")
region = Rect2(200, 100, 100, 100)

[sub_resource type="AtlasTexture" id="AtlasTexture_xs6k8"]
atlas = ExtResource("6_bycy1")
region = Rect2(300, 100, 100, 100)

[sub_resource type="AtlasTexture" id="AtlasTexture_y3ulj"]
atlas = ExtResource("6_bycy1")
region = Rect2(400, 100, 100, 100)

[sub_resource type="AtlasTexture" id="AtlasTexture_wmxfl"]
atlas = ExtResource("6_bycy1")
region = Rect2(500, 100, 100, 100)

[sub_resource type="AtlasTexture" id="AtlasTexture_p5apu"]
atlas = ExtResource("6_bycy1")
region = Rect2(600, 100, 100, 100)

[sub_resource type="AtlasTexture" id="AtlasTexture_rpqyo"]
atlas = ExtResource("6_bycy1")
region = Rect2(700, 100, 100, 100)

[sub_resource type="SpriteFrames" id="SpriteFrames_rnfc7"]
animations = [{
"frames": [{
"duration": 1.0,
"texture": SubResource("AtlasTexture_xw5af")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_xs6k8")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_y3ulj")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_wmxfl")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_p5apu")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_rpqyo")
}],
"loop": false,
"name": &"Anim",
"speed": 18.0
}]

[node name="WallHitEffect" type="CharacterBody3D"]
collision_layer = 0
script = SubResource("GDScript_1gnx5")
spawnable_info = ExtResource("2_5nrjf")

[node name="Hitbox" type="Area3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0.204105, 0)
script = SubResource("GDScript_7meyc")
hit_data = SubResource("Resource_fuwwp")
root_node_path = NodePath("..")
metadata/_custom_type_script = "uid://cm6korv2sfd"

[node name="Shape" type="CollisionShape3D" parent="Hitbox"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -0.00137547, -0.191332, 0)
shape = SubResource("SphereShape3D_fc865")

[node name="Hurtbox" type="Area3D" parent="."]
visible = false
script = SubResource("GDScript_v1h67")
root_node_path = NodePath("..")
metadata/_custom_type_script = "uid://jk40g84p8nlf"

[node name="Shape" type="CollisionShape3D" parent="Hurtbox"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0.206324, 0)
shape = SubResource("SphereShape3D_kpalt")

[node name="CollisionShape3D" type="CollisionShape3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -0.00204468, 0, -0.00158691)
shape = SubResource("BoxShape3D_voyo2")

[node name="Sprite" type="AnimatedSprite3D" parent="."]
transform = Transform3D(4.2, 0, 0, 0, 4.2, 0, 0, 0, 4.2, 0, 0, 0)
texture_filter = 2
sprite_frames = SubResource("SpriteFrames_rnfc7")
animation = &"Anim"

[connection signal="animation_finished" from="Sprite" to="." method="_on_sprite_animation_finished"]
